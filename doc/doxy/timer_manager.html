<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Veins: TimerManager -- Callback-Based Event Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Veins
   </div>
   <div id="projectbrief">The open source vehicular network simulation framework.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('timer_manager.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TimerManager -- Callback-Based Event Handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In some places, OMNeT++ provides mechanisms to react to some sort of event, that are harder to use than they should. It is perfectly possible to implement the reaction to the event, but it involves a lot of boilerplate code and no real abstraction.</p>
<p>One example for this are self messages, which are often used to implement timers (one shot or recurring) for individual modules. To implement a single timer, one typically has to:</p>
<ul>
<li>define a class member to contain the pointer to the cMessage instance.</li>
<li>create the cMessage instance</li>
<li>schedule the cMessage instance</li>
<li>detect the arrival of that particular cMessage, usually in some if-cascade in or called by handleMessage</li>
<li>perform the actual action</li>
<li>possibly re-schedule the message, if the event is recurring</li>
<li>delete the cMessage when done and/or the object gets destroyed</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Example module with a one-shot timer firing 2.5 seconds after initialize and a recurring timer firing every 1 second</span></div><div class="line"><span class="keyword">class </span>WitoutTimers: <span class="keyword">public</span> cSimpleModule {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// define class member to contain the pointer to the cMessage instance</span></div><div class="line">    cMessage* recurringTrigger;</div><div class="line">    cMessage* oneshotTrigger;</div><div class="line">    <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div><div class="line">        <span class="comment">// create the cMessage instance</span></div><div class="line">        recurringTrigger = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;recurring trigger&quot;</span>);</div><div class="line">        oneshotTrigger = <span class="keyword">new</span> cMessage(<span class="stringliteral">&quot;one-shot trigger&quot;</span>);</div><div class="line">        <span class="comment">// schedule the cMessage instance</span></div><div class="line">        scheduleAt(1, recurringTrigger);</div><div class="line">        scheduleAt(2.5, oneshotTrigger);</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> handleMessage(cMessage* msg)<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">if</span> (msg-&gt;isSelfMessage()) {</div><div class="line">            <span class="comment">// detect the arrival of a particular cMessage</span></div><div class="line">            <span class="keywordflow">if</span> (msg == recurringTrigger) {</div><div class="line">                <span class="comment">// perform actual action</span></div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;recurring Timer called from &quot;</span> &lt;&lt; this-&gt;getFullPath() &lt;&lt; std::endl;</div><div class="line">                <span class="comment">// re-schedule the message</span></div><div class="line">                scheduleAt(1, recurringTrigger);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">if</span> (msg == oneshotTrigger) {</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;one-shot timer fired from &quot;</span> &lt;&lt; this-&gt;getFullPath() &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; simTime() &lt;&lt; std::endl;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~WithoutTimers() {</div><div class="line">        <span class="comment">// delete the cMessage when the object gets destroyed</span></div><div class="line">        <span class="keywordflow">if</span>(recurringTrigger) {</div><div class="line">            cancelAndDelete(recurringTrigger);</div><div class="line">            recurringTrigger = <span class="keyword">nullptr</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span>(oneshotTrigger) {</div><div class="line">            cancelAndDelete(oneshotTrigger);</div><div class="line">            oneshotTrigger = <span class="keyword">nullptr</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>This is highly repetitive and scatters code all over the class, which is bad. Furthermore, it has to be repeated for every single timer.</p>
<p>With the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> suite, most of the boilerplate is abstracted away. The <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> contains all of it and provides an interface with clear semantics. Now the only steps left are:</p>
<ul>
<li>per-module setup of the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> instance (only necessary once per module):<ul>
<li>define and instantiate the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a></li>
<li>forward all self-messages to the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> instance (in handleMessage)</li>
</ul>
</li>
<li>define the individual timers:<ul>
<li>encode the reaction to the timer firing in a functor, e.g., a lambda</li>
<li>specify when and how often a timer shall fire by constructing a <a class="el" href="structveins_1_1_timer_specification.html">TimerSpecification</a></li>
<li>register the timer with the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> instance</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Example module with same functionalty as above</span></div><div class="line"><span class="keyword">class </span>WithTimers: <span class="keyword">public</span> cSimpleModule {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <a class="code" href="classveins_1_1_timer_manager.html">veins::TimerManager</a> timerManager(<span class="keyword">this</span>);  <span class="comment">// define and instantiate the TimerManager</span></div><div class="line">    <span class="keywordtype">void</span> handleMessage(cMessage* msg)<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">if</span> (msg-&gt;isSelfMessage()) {</div><div class="line">            timerManager.handleMessage(msg);  <span class="comment">// forward all self-messages to the TimerManager instance</span></div><div class="line">        }</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div><div class="line">        <span class="comment">// encode the reaction to the timer firing with a lambda</span></div><div class="line">        <span class="keyword">auto</span> recurringCallback = [<span class="keyword">this</span>](){</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;recurring Timer called from &quot;</span> &lt;&lt; this-&gt;getFullPath() &lt;&lt; std::endl;</div><div class="line">        };</div><div class="line">        <span class="keyword">auto</span> oneshotCallback = [<span class="keyword">this</span>](){</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;one-shot timer fired from &quot;</span> &lt;&lt; this-&gt;getFullPath() &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; simTime() &lt;&lt; std::endl;</div><div class="line">        };</div><div class="line">        <span class="comment">// specify when and how ofthen a timer shall fire</span></div><div class="line">        <span class="keyword">auto</span> recurringTimerSpec = <a class="code" href="structveins_1_1_timer_specification.html">veins::TimerSpecification</a>(recurringCallback).<a class="code" href="structveins_1_1_timer_specification.html#a1fe5a58cbf8ce66a7c96b1dde3053700">interval</a>(1);</div><div class="line">        <span class="keyword">auto</span> oneshotTimerSpec = <a class="code" href="structveins_1_1_timer_specification.html">veins::TimerSpecification</a>(oneshotCallback).oneshotin(2.5);</div><div class="line">        <span class="comment">// register the timer with the TimerManager instance</span></div><div class="line">        timerManager.create(recurringTimerSpec, <span class="stringliteral">&quot;recurring timer&quot;</span>);</div><div class="line">        timerManager.create(oneshotTimerSpec, <span class="stringliteral">&quot;one-shot timer&quot;</span>);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note: the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> works fine with self-messages not handled by it. The return code of <a class="el" href="classveins_1_1_timer_manager.html#a2ae39de41dbf73cc83f02d467c0b5a88">TimerManager::handleMessage()</a> indicates whether the message passed to it could be handled by a timer. </p><div class="fragment"><div class="line"><span class="comment">// Alternative implementation for co-existence with other self-messages</span></div><div class="line">    <span class="keywordtype">void</span> handleMessage(cMessage* msg)<span class="keyword"> override </span>{</div><div class="line">        <span class="keywordflow">if</span> (msg-&gt;isSelfMessage() &amp;&amp; timerManager.handleMessage(msg)) <span class="keywordflow">return</span>;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div></div><!-- fragment --><p>All cleanup and re-scheduling chores are done by the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> As the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> instance can be value member (and not a pointer to a heap-allocated object like cMessage), there is no need for a custom destructor.</p>
<p>When using inheritance trees, the <a class="el" href="classveins_1_1_timer_manager.html">TimerManager</a> can easily used by different levels (as long as it is a protected or public member or accessible otherwise). Even multiple instances coule be used, as long as message delegation is correctly implemented. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Veins User Manual</a></li>
    <li class="footer">Generated on Thu Nov 12 2020 23:01:51 for Veins by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
